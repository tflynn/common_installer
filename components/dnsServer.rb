#!/usr/bin/env jruby

require 'fileutils'

remoteRequire 'installerLogger'
remoteRequire 'networkHelper'
remoteRequire 'components/gnuBuild'
remoteRequire 'ioHelpers'
remoteRequire 'osHelpers'

class DnsServer < GnuBuild

  def initialize
    super
    @settings = COMPONENT_OPTIONS.dnsServer
  end
  
  def canBeInstalled?
    if @settings.osSpecific.nil?
      return true
    else
      desiredOS = @settings.osSpecific
      if desiredOS.downcase == OSHelpers.getSystemType
        return true
      else
        logger.warn("#{@settings.name} can only be installed on #{desiredOS}")
        return false
      end
    end
  end
  
  def alreadyInstalled?
    logger.info("Component: #{@settings.name} : Checking for presence of file '/etc/mararc' . File #{File.exists?('/etc/mararc') ? 'is' : 'is not'} present so component #{File.exists?('/etc/mararc') ? 'is' : 'is not'} already installed.")
    return File.exists?('/etc/mararc')
  end
  
  def configureBuild
    # puts "Entering DnsServer.configureBuild"
    # caller[0,5].each do |callEntry|
    #   puts "DnsServer.configureBuild #{callEntry}"
    # end
    FileUtils.mkdir_p("#{@settings.buildInstallationDirectory}/sbin")
    executeWithErrorCheck do
      options = getOptions.dup
      options[:customConfigureBuildCommand] = "export PREFIX=#{@settings.buildInstallationDirectory}   ; ./configure"
      results = BuildHelper.configureBuild(@settings,options)
      @status = results[:retVal]
      { :status => @status, :errorMsg => results[:errorMsg] }
    end
  end
  
  def make
    executeWithErrorCheck do
      options = getOptions.dup
      options[:customMakeCommand] = "export PREFIX=#{@settings.buildInstallationDirectory}   ; make"
      results = BuildHelper.make(@baseFileName,@settings,options)
      @status = results[:retVal]
      { :status => @status, :errorMsg => results[:errorMsg] }
    end
  end
  
  def install
    executeWithErrorCheck do
      options = getOptions.dup
      options[:customMakeInstallCommand] = "export PREFIX=#{@settings.buildInstallationDirectory}   ; make install"
      results = BuildHelper.install(@baseFileName,@settings,options)
      @status = results[:retVal]
      { :status => @status, :errorMsg => results[:errorMsg] }
    end
  end
  
  def configure

    ipAddress = nil
    primaryDomain = nil
    status = nil
    errorMsg = nil
    executeWithErrorCheck do
      begin
        if alreadyInstalled?
          if defined?(::DNS_PRIMARY_IP)
            ipAddress = ::DNS_PRIMARY_IP
          else
            ipAddress = NetworkHelper.getPrimaryIPAddress unless ipAddress
            # if ipAddress
            #   puts "DnsServer.configure ipAddress #{ipAddress}"
            # else
            #   puts "DnsServer.configure no IP address found"
            # end
            userIpAddress = IOHelpers.readKeyboardWithPrompt("#{@settings.name} : Enter Primary IP address (#{ipAddress})")
            if userIpAddress != ''
              ipAddress = userIpAddress
            end
          end
          if defined?(::DNS_PRIMARY_DOMAIN)
            primaryDomain = ::DNS_PRIMARY_DOMAIN
          else
            while primaryDomain.nil?
              primaryDomain = IOHelpers.readKeyboardWithPrompt("#{@settings.name} : Enter Primary domain")
              if primaryDomain == ''
                primaryDomain = nil
              end
            end
          end
          mararc = <<MARARC
#Automatically generated by CommonInstaller
ipv4_bind_addresses = "#{ipAddress}"
chroot_dir = "/etc/maradns"
csv2 = {}
csv2["#{primaryDomain}."] = "db.#{primaryDomain}"
MARARC

          domainZone = <<DOMAIN_ZONE
#Automatically generated by CommonInstaller
*.#{primaryDomain}. #{ipAddress} ~
DOMAIN_ZONE

          #puts "mararc \n#{mararc}"
          #puts "domainZone \n#{domainZone}"
      
          IOHelpers.overwriteFile('/etc/mararc',mararc)
          IOHelpers.overwriteFile("/etc/maradns/db.#{primaryDomain}",domainZone)
          logger.info(%{#{@settings.name} : Server has been configured successfully })
          status = SUCCESS
        end
      rescue Exception => ex
        status = FAILURE
        errorMsg = %{Unexpected error encountered while configuring #{@settings.name} \n #{ex.to_s} \n #{ex.join.backtrace("\n")}}
      end
      
      {:status => status , :errorMsg => errorMsg}
    end
  
  end

  def run
    status = nil
    errorMsg = nil
    executeWithErrorCheck do
      autoStart = false
      if defined?(::DNS_SERVER_AUTO_START)
        autostart = ::DNS_SERVER_AUTO_START
      end
      begin
        if autostart
          
        end
        status = SUCCESS
      rescue Exception => ex
        status = FAILURE
        errorMsg = %{Unexpected error encountered while running #{@settings.name} \n #{ex.to_s} \n #{ex.join.backtrace("\n")}}
      end
      {:status => status , :errorMsg => errorMsg}  
    end
  end
  
  def afterEverything
    logger.info("Component #{@settings.name} successfully installed, configured and run")
  end
    
end
